import logging
import threading
import queue
import numpy as np
import time

from pathlib import Path
from gi.repository import Gst, GLib
from sttutils import *
from sttgstbase import STTGstBase
from sttcurrentlocale import stt_current_locale
from sttwhispermodel import STTWhisperModel

LOG_MSG = logging.getLogger()

try:
    from pywhispercpp.model import Model
    WHISPER_AVAILABLE = True
except ImportError:
    LOG_MSG.warning("pywhispercpp not available. Install with: pip install pywhispercpp")
    WHISPER_AVAILABLE = False


class STTGstWhisper(STTGstBase):
    __gtype_name__ = 'STTGstWhisper'
    _pipeline_def = "pulsesrc blocksize=3200 buffer-time=9223372036854775807 ! " \
                    "audio/x-raw,format=S16LE,rate=16000,channels=1 ! " \
                    "webrtcdsp noise-suppression-level=3 echo-cancel=false ! " \
                    "queue ! " \
                    "appsink name=WhisperSink emit-signals=true sync=false"

    _pipeline_def_alt = "pulsesrc blocksize=3200 buffer-time=9223372036854775807 ! " \
                        "audio/x-raw,format=S16LE,rate=16000,channels=1 ! " \
                        "queue ! " \
                        "appsink name=WhisperSink emit-signals=true sync=false"

    def __init__(self, current_locale=None):
        plugin = Gst.Registry.get().find_plugin("webrtcdsp")
        if plugin is not None:
            super().__init__(pipeline_definition=STTGstWhisper._pipeline_def)
            LOG_MSG.debug("using Webrtcdsp plugin")
        else:
            super().__init__(pipeline_definition=STTGstWhisper._pipeline_def_alt)
            LOG_MSG.debug("not using Webrtcdsp plugin")

        if self.pipeline is None:
            LOG_MSG.error("pipeline was not created")
            return

        self._appsink = self.pipeline.get_by_name("WhisperSink")
        if self._appsink is None:
            LOG_MSG.error("no appsink element!")
            return

        self._appsink.connect("new-sample", self._on_new_sample)

        if current_locale is None:
            self._current_locale = stt_current_locale()
        else:
            self._current_locale = current_locale

        self._locale_id = self._current_locale.connect("changed", self._locale_changed)

        self._model_id = 0
        self._model = None
        self._whisper = None
        self._set_model()

        self._audio_buffer = []
        self._buffer_duration = 0.0
        self._max_buffer_duration = 6.0   # force-flush at this duration
        self._min_buffer_duration = 0.5   # don't process tiny fragments
        self._silence_duration = 1.2      # flush after this many seconds of silence
        self._sample_rate = 16000
        self._process_queue = queue.Queue()
        self._process_thread = None
        self._stop_processing = False

        self._last_audio_ts = 0.0         # monotonic time of last received sample
        self._silence_timer_id = 0        # GLib timer id for silence detection

        self._use_partial_results = False

    def __del__(self):
        LOG_MSG.info("Whisper __del__")
        self._stop_processing = True
        if self._process_thread is not None:
            self._process_thread.join(timeout=2.0)
        super().__del__()

    def destroy(self):
        self._stop_processing = True

        if self._silence_timer_id != 0:
            GLib.source_remove(self._silence_timer_id)
            self._silence_timer_id = 0

        if self._process_thread is not None:
            self._process_thread.join(timeout=2.0)

        self._current_locale.disconnect(self._locale_id)
        self._locale_id = 0

        if self._model_id != 0:
            self._model.disconnect(self._model_id)
            self._model_id = 0

        self._appsink = None
        self._whisper = None

        LOG_MSG.info("Whisper.destroy() called")
        super().destroy()

    def _load_whisper_model(self, model_path):
        """Load Whisper model using pywhispercpp"""
        if not WHISPER_AVAILABLE:
            LOG_MSG.error("pywhispercpp not available")
            return False

        try:
            LOG_MSG.info("Loading Whisper model: %s", model_path)

            lang_code = None
            if self._current_locale and self._current_locale.locale:
                lang_code = self._current_locale.locale[:2]

            if lang_code and lang_code != 'multilingual':
                self._whisper = Model(model_path, language=lang_code,
                                     print_realtime=False, print_progress=False)
            else:
                self._whisper = Model(model_path,
                                     print_realtime=False, print_progress=False)

            LOG_MSG.info("Whisper model loaded successfully")
            return True

        except Exception as e:
            LOG_MSG.error("Failed to load Whisper model: %s", e)
            self._whisper = None
            return False

    def _set_model_path(self):
        if self._model is None or self._model.available() is False:
            LOG_MSG.info("model path does not exist (%s - %s)",
                        self._model.get_name() if self._model else "None",
                        self._model.get_path() if self._model else "None")
            self._whisper = None
            self.emit("model-changed")
            return

        new_model_path = self._model.get_path()
        LOG_MSG.debug("model ready %s", new_model_path)

        # Load the model
        ret, state, pending = self.pipeline.get_state(0)
        if state >= Gst.State.READY:
            self.pipeline.set_state(Gst.State.READY)

        success = self._load_whisper_model(new_model_path)

        if state >= Gst.State.READY:
            self.pipeline.set_state(state)

        if success:
            self.emit("model-changed")

    def _model_changed(self, model):
        self._set_model_path()

    def _set_model(self):
        if self._model is not None and \
           self._model.get_locale() == self._current_locale.locale:
            return

        if self._model_id != 0:
            self._model.disconnect(self._model_id)
            self._model_id = 0

        self._model = STTWhisperModel(locale_str=self._current_locale.locale)
        self._model_id = self._model.connect("changed", self._model_changed)
        self._set_model_path()

    def _locale_changed(self, locale):
        self._set_model()

    def _on_new_sample(self, appsink):
        """Callback when new audio sample arrives"""
        sample = appsink.emit("pull-sample")
        if sample is None:
            return Gst.FlowReturn.OK

        buf = sample.get_buffer()
        success, map_info = buf.map(Gst.MapFlags.READ)
        if not success:
            return Gst.FlowReturn.OK

        audio_data = np.frombuffer(map_info.data, dtype=np.int16)
        buf.unmap(map_info)

        self._audio_buffer.append(audio_data)
        self._buffer_duration += len(audio_data) / self._sample_rate
        self._last_audio_ts = time.monotonic()

        # Force-flush if buffer is very long
        if self._buffer_duration >= self._max_buffer_duration:
            self._process_audio_buffer()
            return Gst.FlowReturn.OK

        # Arm silence-detection timer (runs on GLib main loop every 300 ms)
        if self._silence_timer_id == 0:
            self._silence_timer_id = GLib.timeout_add(300, self._silence_check_cb)

        return Gst.FlowReturn.OK

    def _silence_check_cb(self):
        """GLib timer: flush buffer if speech has paused long enough"""
        if len(self._audio_buffer) == 0:
            self._silence_timer_id = 0
            return False  # cancel timer

        elapsed_silence = time.monotonic() - self._last_audio_ts
        if elapsed_silence >= self._silence_duration \
                and self._buffer_duration >= self._min_buffer_duration:
            LOG_MSG.debug("Silence detected (%.2fs), flushing buffer (%.2fs)",
                         elapsed_silence, self._buffer_duration)
            self._process_audio_buffer()
            self._silence_timer_id = 0
            return False  # cancel timer

        return True  # keep timer running

    def _process_audio_buffer(self):
        """Process accumulated audio buffer"""
        # Cancel any pending silence timer since we're flushing now
        if self._silence_timer_id != 0:
            GLib.source_remove(self._silence_timer_id)
            self._silence_timer_id = 0

        if len(self._audio_buffer) == 0:
            return

        if self._buffer_duration < self._min_buffer_duration:
            LOG_MSG.debug("Buffer too short (%.2fs), waiting for more audio", self._buffer_duration)
            return

        if self._whisper is None:
            LOG_MSG.warning("Whisper model not loaded")
            self._audio_buffer.clear()
            self._buffer_duration = 0.0
            return

        audio = np.concatenate(self._audio_buffer)
        self._audio_buffer.clear()
        self._buffer_duration = 0.0

        LOG_MSG.debug("Processing audio buffer: %d samples (%.2f seconds)",
                     len(audio), len(audio) / self._sample_rate)

        audio_float = audio.astype(np.float32) / 32768.0

        self._process_queue.put(audio_float)

        if self._process_thread is None or not self._process_thread.is_alive():
            self._stop_processing = False   # reset in case thread was previously stopped
            self._process_thread = threading.Thread(target=self._process_worker, daemon=True)
            self._process_thread.start()

    def _process_worker(self):
        """Background worker to process audio"""
        while not self._stop_processing:
            try:
                audio = self._process_queue.get(timeout=0.1)
            except queue.Empty:
                continue

            if self._whisper is None:
                self._process_queue.task_done()
                continue

            try:
                LOG_MSG.debug("Starting transcription of %d samples", len(audio))

                segments = self._whisper.transcribe(audio)

                text_parts = []
                for segment in segments:
                    if hasattr(segment, 'text'):
                        segment_text = segment.text.strip()
                        if segment_text:
                            text_parts.append(segment_text)
                            LOG_MSG.debug("Segment text: '%s'", segment_text)

                text = ' '.join(text_parts).strip()

                if text:
                    LOG_MSG.info("Whisper transcription result: '%s'", text)
                    GLib.idle_add(self._emit_text, text)
                else:
                    LOG_MSG.debug("No text transcribed from audio")

            except Exception as e:
                LOG_MSG.error("Whisper transcription error: %s", e, exc_info=True)

            self._process_queue.task_done()

    def _emit_text(self, text):
        self.emit("text", text)
        return False

    def get_final_results(self):
        if len(self._audio_buffer) > 0:
            self._process_audio_buffer()
        self._process_queue.join()

    def get_results(self):
        pass

    def set_use_partial_results(self, active):
        self._use_partial_results = active

    def set_alternatives_num(self, num):
        pass

    def has_model(self):
        if self._model is None or self._model.available() is False:
            return False
        return super().has_model()

    def _stop_real(self):
        self.get_final_results()
        return super()._stop_real()





















import os
import json
import logging
from re import search
from pathlib import Path
import urllib.request
from enum import Enum
import tempfile
import shutil
import uuid
import threading

from gi.repository import GObject, Gio, GLib

LOG_MSG = logging.getLogger()

# Whisper model directories
MODEL_DIRS = [
    os.getenv('WHISPER_MODEL_PATH'),
    Path.home() / '.cache/whisper',
    Path('/usr/share/whisper'),
    Path('/usr/local/share/whisper')
]

# Hugging Face model repository
MODEL_PRE_URL = 'https://huggingface.co/ggerganov/whisper.cpp/resolve/main/'
WHISPER_MODELS = {
    # Full precision
    'tiny':               'ggml-tiny.bin',
    'tiny.en':            'ggml-tiny.en.bin',
    'base':               'ggml-base.bin',
    'base.en':            'ggml-base.en.bin',
    'small':              'ggml-small.bin',
    'small.en':           'ggml-small.en.bin',
    'medium':             'ggml-medium.bin',
    'medium.en':          'ggml-medium.en.bin',
    'large-v1':           'ggml-large-v1.bin',
    'large-v2':           'ggml-large-v2.bin',
    'large-v3':           'ggml-large-v3.bin',
    'large-v3-turbo':     'ggml-large-v3-turbo.bin',
    # Quantized
    'tiny-q5_1':          'ggml-tiny-q5_1.bin',
    'tiny.en-q5_1':       'ggml-tiny.en-q5_1.bin',
    'base-q5_1':          'ggml-base-q5_1.bin',
    'base.en-q5_1':       'ggml-base.en-q5_1.bin',
    'small-q5_1':         'ggml-small-q5_1.bin',
    'small.en-q5_1':      'ggml-small.en-q5_1.bin',
    'medium-q5_0':        'ggml-medium-q5_0.bin',
    'medium.en-q5_0':     'ggml-medium.en-q5_0.bin',
    'large-v2-q5_0':      'ggml-large-v2-q5_0.bin',
    'large-v3-q5_0':      'ggml-large-v3-q5_0.bin',
    'large-v3-turbo-q5_0':'ggml-large-v3-turbo-q5_0.bin',
}

# Quantization suffixes for filename parsing
QUANTIZATION_TYPES = {'q4_0', 'q4_1', 'q5_0', 'q5_1', 'q8_0'}

DOWNLOADED_MODEL_SUFFIX = ".downloaded_model_tmp"

def _helper_locale_normalize(locale_str):
    lang = locale_str[0:2].lower()
    if len(locale_str) < 5:
        return lang

    lang2 = locale_str[3:5]
    return lang + "_" + lang2.upper()

class STTDownloadState(float, Enum):
    STOPPED = -1.0
    UNKNOWN_PROGRESS = -0.5
    UNPACKING = -0.6
    ONGOING = 0.0

class STTWhisperModelDescription(GObject.Object):
    __gtype_name__ = "STTWhisperModelDescription"

    def __init__(self, init_model=None):
        super().__init__()
        self.name = init_model.name if init_model is not None else ""
        self.custom = init_model.custom if init_model is not None else False
        self.is_obsolete = False
        self.paths = init_model.paths if init_model is not None else []
        self.size = init_model.size if init_model is not None else ""
        self.type = init_model.type if init_model is not None else ""
        self.locale = init_model.locale if init_model is not None else ""
        self.url = init_model.url if init_model is not None else ""

        self._operation = None
        self.download_progress = STTDownloadState.STOPPED

    def _download_finished(self):
        if self._operation.is_cancelled():
            self._operation = None

    def _download_model_thread(self, download_link, destination, status):
        with urllib.request.urlopen(download_link) as response:
            length_str = response.getheader('content-length')
            blocksize = 4096
            if length_str:
                length = int(length_str)
                blocksize = max(blocksize, length // 20)
            else:
                length = 0

            destination.parent.mkdir(parents=True, exist_ok=True)
            copy_id = uuid.uuid4()
            tmp_dst = Path(str(destination) + str(copy_id) + DOWNLOADED_MODEL_SUFFIX)

            try:
                with open(tmp_dst, 'wb') as tmp_file:
                    size = 0
                    while True:
                        if status.is_cancelled():
                            tmp_file.close()
                            if tmp_dst.exists():
                                tmp_dst.unlink()
                            return

                        buffer = response.read(blocksize)
                        if buffer is None or len(buffer) == 0:
                            break

                        tmp_file.write(buffer)
                        size += len(buffer)
                        if length != 0:
                            self.download_progress = size / length
                        else:
                            self.download_progress = STTDownloadState.UNKNOWN_PROGRESS

                os.rename(tmp_dst, destination)

                if status.is_cancelled():
                    if destination.exists():
                        destination.unlink()

            except Exception as e:
                LOG_MSG.error("Download error: %s", e)
                if tmp_dst.exists():
                    tmp_dst.unlink()

        self.download_progress = STTDownloadState.STOPPED
        GLib.idle_add(self._download_finished)

    def stop_downloading(self):
        if self._operation is not None:
            self._operation.cancel()

    def start_downloading(self):
        if self._operation is not None:
            return

        LOG_MSG.debug("start downloading model (%s)", self.url)

        self.download_progress = STTDownloadState.ONGOING
        self._operation = Gio.Cancellable()

        download_thread = threading.Thread(
            target=self._download_model_thread,
            args=(self.url, Path(MODEL_DIRS[1], self.name), self._operation)
        )
        download_thread.start()

    def get_best_path_for_model(self):
        if self.paths in [None, []]:
            return None

        return self.paths[0]

    def delete_paths(self):
        if self.custom is True:
            return

        for path in self.paths:
            if Path(path).parent == MODEL_DIRS[1] and self.url is not None:
                try:
                    Path(path).unlink()
                except Exception as e:
                    LOG_MSG.error("Failed to delete %s: %s", path, e)

        self._operation = None
        self.download_progress = STTDownloadState.STOPPED
        self.paths = []

class STTWhisperLocalModelManager(GObject.Object):
    __gtype_name__ = "STTWhisperLocalModelManager"

    __gsignals__ = {
        "added": (GObject.SIGNAL_RUN_FIRST, None, (str, str,)),
        "removed": (GObject.SIGNAL_RUN_FIRST, None, (str, str,)),
    }

    def __init__(self):
        super().__init__()
        self._monitors = []
        self._models_dict = {}
        self._locales_dict = {}
        self._model_paths_dict = {}
        self._get_available_local_models()
        self._custom_paths = {}

    def _add_model_description_to_locale(self, model_desc):
        if model_desc.locale is None:
            return

        models_list = self._locales_dict.get(model_desc.locale, None)
        if models_list is None:
            self._locales_dict[model_desc.locale] = [model_desc]
        else:
            models_list.append(model_desc)

    def _new_model_available(self, model_path):

        if str(model_path).endswith(DOWNLOADED_MODEL_SUFFIX):
            LOG_MSG.debug("model path is a temporary file (%s)", model_path)
            return None

        if not model_path.is_file():
            LOG_MSG.debug("model path is not a file (%s)", model_path)
            return None

        if not model_path.name.endswith('.bin'):
            LOG_MSG.debug("model path is not a .bin file (%s)", model_path)
            return None

        if not os.access(model_path, os.R_OK):
            LOG_MSG.debug("access rights are wrong (%s)", model_path)
            return None

        if self.path_available(str(model_path)):
            LOG_MSG.debug("model file already in list (%s)", model_path)
            return None

        locale_str = None
        model_type = None
        model_name = model_path.name

        if model_name.startswith("ggml-"):
            # Strip "ggml-" prefix and ".bin" suffix
            # e.g. "ggml-small.en-q5_1.bin" -> stem = "small.en-q5_1"
            stem = model_name.removeprefix("ggml-").removesuffix(".bin")

            # Detect and strip quantization suffix (e.g. "-q5_1")
            quant_suffix = ""
            for qt in QUANTIZATION_TYPES:
                if stem.endswith("-" + qt):
                    quant_suffix = "-" + qt
                    stem = stem[: -len(quant_suffix)]
                    break

            # stem is now the base name, e.g. "small.en" or "large-v3"
            model_type = stem + quant_suffix  # e.g. "small.en-q5_1" or "large-v3-q5_0"

            if ".en" in stem:
                locale_str = "en"
            else:
                locale_str = "multilingual"
        else:
            LOG_MSG.debug("non-standard name format (%s)", model_path)

        if model_path.parent not in MODEL_DIRS:
            model_desc = STTWhisperModelDescription()
            model_desc.paths = [str(model_path)]
            model_desc.name = model_name
            model_desc.custom = True
            model_desc.locale = locale_str
            model_desc.type = model_type

            self._models_dict[str(model_path)] = model_desc
            self._model_paths_dict[str(model_path)] = model_desc

            LOG_MSG.debug("custom model file is valid (%s)", model_path)
            return model_desc

        model_desc = self._models_dict.get(model_name, None)
        if model_desc is None:
            model_desc = STTWhisperModelDescription()
            model_desc.paths = [str(model_path)]
            model_desc.locale = locale_str
            model_desc.type = model_type
            model_desc.name = model_name

            self._add_model_description_to_locale(model_desc)
            self._models_dict[model_desc.name] = model_desc
            self._model_paths_dict[str(model_path)] = model_desc

            LOG_MSG.debug("model file is valid (%s) - name not known yet", model_path)
            self.emit("added", model_name, str(model_path))
            return model_desc

        model_desc.paths.append(str(model_path))
        model_desc.paths.sort(key=lambda element: MODEL_DIRS.index(Path(element).parent))

        LOG_MSG.debug("model file is valid (%s) - name already known", model_path)
        self.emit("added", model_name, str(model_path))
        return model_desc

    def _remove_model_description(self, model_path):
        model_desc = self._model_paths_dict.pop(model_path, None)
        if model_desc is None:
            return

        LOG_MSG.debug("model file removed (%s)", model_path)

        model_desc.paths.remove(model_path)
        if not any(model_desc.paths):
            models_list = self._locales_dict.get(model_desc.locale, [])
            if model_desc in models_list:
                models_list.remove(model_desc)
            if not any(models_list):
                self._locales_dict.pop(model_desc.locale, None)

            key = model_desc.name if model_desc.custom is False else model_path
            self._models_dict.pop(key, None)

        model_name = model_desc.name if model_desc.custom is False else None
        self.emit("removed", model_name, model_path)

    def _model_file_changed_cb(self, monitor, file, other_file, event_type):
        LOG_MSG.debug("a file changed (source = %s) %s %s", self, file.get_path(), event_type)

        if file.get_path() in [str(d) for d in MODEL_DIRS if d]:
            LOG_MSG.debug("change does not concern a child of a top directory. Ignoring.")
            return

        LOG_MSG.info("a model file changed (%s) (event=%s)", file.get_path(), event_type)
        if event_type == Gio.FileMonitorEvent.CHANGES_DONE_HINT:
            if file.get_path().endswith(DOWNLOADED_MODEL_SUFFIX):
                LOG_MSG.debug("temporary file ignored (%s)", file.get_path())
                return

            self._new_model_available(Path(file.get_path()))
        elif event_type == Gio.FileMonitorEvent.DELETED:
            self._remove_model_description(file.get_path())

    def _get_available_local_models(self):
        for directory in MODEL_DIRS:
            LOG_MSG.debug("scanning %s for models", directory)

            if directory is None:
                continue

            monitor = Gio.File.new_for_path(str(directory)).monitor(Gio.FileMonitorFlags.NONE, None)
            monitor.connect("changed", self._model_file_changed_cb)
            self._monitors.append(monitor)

            directory_path = Path(directory)
            if not directory_path.is_dir():
                continue

            for child in directory_path.iterdir():
                LOG_MSG.debug("scanning file (%s)", str(child))
                self._new_model_available(child)

    def path_available(self, model_path):
        return model_path in self._model_paths_dict

    def get_models_for_locale(self, locale_str):
        models = self._locales_dict.get(locale_str, []).copy()
        multilingual = self._locales_dict.get("multilingual", [])
        models.extend(multilingual)
        return models

    def get_best_path_for_model(self, model_name):
        if model_name is None:
            return None

        model = self._models_dict.get(model_name, None)
        if model is None:
            return None

        if model.paths in [None, []]:
            return None

        return model.paths[0]

    def get_model_description(self, model_name):
        return self._models_dict.get(model_name, None)

    def get_supported_locales(self):
        return list(self._locales_dict.keys())

    def _custom_model_file_changed_cb(self, monitor, file, other_file, event_type):
        LOG_MSG.info("a custom model file changed (%s) (event=%s)", file.get_path(), event_type)
        if event_type == Gio.FileMonitorEvent.CHANGES_DONE_HINT:
            self._new_model_available(Path(file.get_path()))
        elif event_type == Gio.FileMonitorEvent.DELETED:
            model = self._model_paths_dict.get(file.get_path(), None)
            if model is None:
                return

            LOG_MSG.debug("custom model file removed (%s)", file.get_path())
            self._model_paths_dict.pop(file.get_path(), None)
            self.emit("removed", None, file.get_path())

    def register_custom_model_path(self, model_path_str, locale_str):
        if Path(model_path_str).parent in MODEL_DIRS:
            LOG_MSG.debug("registered a path in default directories (%s)", model_path_str)
            return

        monitor = self._custom_paths.get(model_path_str, None)
        if monitor is not None:
            monitor.refcount += 1
            LOG_MSG.debug("custom path already registered (%s). Increasing refcount (%i).",
                         model_path_str, monitor.refcount)
            return

        monitor = Gio.File.new_for_path(model_path_str).monitor_file(Gio.FileMonitorFlags.NONE, None)
        monitor.connect("changed", self._custom_model_file_changed_cb)
        self._custom_paths[model_path_str] = monitor
        monitor.refcount = 1

        model_desc = self._new_model_available(Path(model_path_str))
        if model_desc:
            model_desc.locale = locale_str
            self._add_model_description_to_locale(model_desc)
            self.emit("added", None, model_path_str.rstrip("/"))

    def unregister_custom_model_path(self, model_path_str):
        monitor = self._custom_paths.get(model_path_str, None)
        if monitor is None:
            LOG_MSG.debug("trying to unregister a path not in custom model paths (%s)", model_path_str)
            return

        if monitor.refcount != 1:
            LOG_MSG.debug("refcount of custom path not 0 yet (%s)", model_path_str)
            monitor.refcount -= 1
            return

        self._custom_paths.pop(model_path_str, None)
        self._remove_model_description(model_path_str)

_GLOBAL_LOCAL_MANAGER = None

def stt_whisper_local_model_manager():
    global _GLOBAL_LOCAL_MANAGER
    if _GLOBAL_LOCAL_MANAGER is None:
        _GLOBAL_LOCAL_MANAGER = STTWhisperLocalModelManager()
    return _GLOBAL_LOCAL_MANAGER

class STTWhisperOnlineModelManager(GObject.Object):
    __gtype_name__ = "STTWhisperOnlineModelManager"
    __gsignals__ = {
        "added": (GObject.SIGNAL_RUN_FIRST, None, (object,)),
        "changed": (GObject.SIGNAL_RUN_FIRST, None, (object,)),
        "removed": (GObject.SIGNAL_RUN_FIRST, None, (object,)),
    }

    def __init__(self):
        super().__init__()

        self._locales_dict = {}
        self._online_models = {}

        local_manager = stt_whisper_local_model_manager()
        local_manager.connect("added", self._model_path_added_cb)
        local_manager.connect("removed", self._model_path_removed_cb)
        self._populate_with_whisper_models()

    def _populate_with_whisper_models(self):
        model_sizes = {
            # Full precision
            'tiny': '75 MB',            'tiny.en': '75 MB',
            'base': '142 MB',           'base.en': '142 MB',
            'small': '466 MB',          'small.en': '466 MB',
            'medium': '1.5 GB',         'medium.en': '1.5 GB',
            'large-v1': '2.9 GB',       'large-v2': '2.9 GB',
            'large-v3': '2.9 GB',       'large-v3-turbo': '809 MB',
            # Quantized
            'tiny-q5_1': '31 MB',       'tiny.en-q5_1': '31 MB',
            'base-q5_1': '57 MB',       'base.en-q5_1': '57 MB',
            'small-q5_1': '181 MB',     'small.en-q5_1': '181 MB',
            'medium-q5_0': '514 MB',    'medium.en-q5_0': '514 MB',
            'large-v2-q5_0': '1.1 GB',  'large-v3-q5_0': '1.1 GB',
            'large-v3-turbo-q5_0': '294 MB',
        }

        for model_name, filename in WHISPER_MODELS.items():
            model_desc = STTWhisperModelDescription()
            model_desc.name = filename
            model_desc.url = MODEL_PRE_URL + filename
            model_desc.size = model_sizes.get(model_name, 'Unknown')

            if '.en' in model_name:
                model_desc.locale = 'en'
                model_desc.type = model_name
            else:
                model_desc.locale = 'multilingual'
                model_desc.type = model_name

            LOG_MSG.debug("adding online model (%s)", model_desc.name)

            local_desc = stt_whisper_local_model_manager().get_model_description(model_desc.name)
            if local_desc is not None:
                model_desc.paths = local_desc.paths

            if model_desc.name in self._online_models:
                existing = self._online_models[model_desc.name]
                if not existing.paths and model_desc.paths:
                    existing.paths = model_desc.paths
                continue

            self._online_models[model_desc.name] = model_desc
            self._add_model_description_to_locale(model_desc)

        for locale in stt_whisper_local_model_manager().get_supported_locales():
            model_list = stt_whisper_local_model_manager().get_models_for_locale(locale)
            LOG_MSG.debug("adding local models for locale (%s)", locale)
            for model_desc in model_list:
                key = model_desc.name if model_desc.custom is False else model_desc.paths[0]
                if key in self._online_models:
                    continue

                if model_desc.custom is False:
                    bin_key = key if key.endswith('.bin') else key + '.bin'
                    if bin_key in self._online_models or key.replace('.bin', '') in self._online_models:
                        continue

                LOG_MSG.debug("adding local model to online dict (%s)", key)
                self._online_models[key] = model_desc
                self._add_model_description_to_locale(model_desc)

    def _add_model_description_to_locale(self, model_desc):
        locale_models = self._locales_dict.get(model_desc.locale, None)

        if locale_models is None:
            self._locales_dict[model_desc.locale] = [model_desc]
        else:
            locale_models.append(model_desc)

    def _model_path_added_cb(self, manager, model_name, model_path):
        if model_name is not None:
            online_model_desc = self._online_models.get(model_name, None)
            local_model_desc = manager.get_model_description(model_name)
        else:
            online_model_desc = self._online_models.get(model_path, None)
            local_model_desc = manager.get_model_description(model_path)

        if online_model_desc is not None:
            if online_model_desc.paths in [None, []]:
                online_model_desc.paths = local_model_desc.paths

            self.emit("changed", online_model_desc)
            return

        key = local_model_desc.name if local_model_desc.custom is False else local_model_desc.paths[0]
        self._online_models[key] = local_model_desc
        self._add_model_description_to_locale(local_model_desc)
        self.emit("added", local_model_desc)

    def _remove_model_description_from_locale(self, model_desc):
        locale_models = self._locales_dict.get(model_desc.locale, None)
        if locale_models and model_desc in locale_models:
            locale_models.remove(model_desc)
        if not any(locale_models):
            self._locales_dict.pop(model_desc.locale, None)

    def _model_path_removed_cb(self, manager, model_name, model_path):
        if model_name is None:
            online_model_desc = self._online_models.pop(model_path, None)
            if online_model_desc:
                self._remove_model_description_from_locale(online_model_desc)
                self.emit("removed", online_model_desc)
            return

        online_model_desc = self._online_models.get(model_name, None)
        if online_model_desc is None:
            return

        if any(online_model_desc.paths):
            self.emit("changed", online_model_desc)
            return

        if online_model_desc.url is not None:
            self.emit("changed", online_model_desc)
            return

        self._online_models.pop(model_name, None)
        self._remove_model_description_from_locale(online_model_desc)
        self.emit("removed", online_model_desc)

    def get_model_description(self, model_name):
        return self._online_models.get(model_name, None)

    def get_models_for_locale(self, locale_str):
        models = self._locales_dict.get(locale_str, []).copy()
        if locale_str != 'multilingual':
            multilingual = self._locales_dict.get('multilingual', [])
            models.extend(multilingual)
        return models

    def supported_locales(self):
        return list(self._locales_dict.keys())

_GLOBAL_ONLINE_MANAGER = None

def stt_whisper_online_model_manager():
    global _GLOBAL_ONLINE_MANAGER
    if _GLOBAL_ONLINE_MANAGER is None:
        _GLOBAL_ONLINE_MANAGER = STTWhisperOnlineModelManager()
    return _GLOBAL_ONLINE_MANAGER























def _load_whisper_model(self, model_path):
    lang_code = None
    if self._current_locale and self._current_locale.locale:
        locale = self._current_locale.locale
        if locale not in ('multilingual', '', None):
            lang_code = locale[:2].lower()
    
    params = dict(print_realtime=False, print_progress=False)
    if lang_code:
        params['language'] = lang_code
    
    self._whisper = Model(model_path, **params)











def _load_whisper_model(self, model_path):
    if not WHISPER_AVAILABLE:
        LOG_MSG.error("pywhispercpp not available")
        return False

    try:
        lang_code = "en"
        if self._current_locale and self._current_locale.locale:
            lang_code = self._current_locale.locale[:2]

        LOG_MSG.info("Loading Whisper model: %s (language=%s)", model_path, lang_code)

        self._whisper = Model(
            model_path,
            language=lang_code,   # ðŸ”´ ALWAYS FORCE
            n_threads=2,
            translate=False,
            print_realtime=False,
            print_progress=False,
        )

        LOG_MSG.info("Whisper model loaded successfully")
        return True

    except Exception as e:
        LOG_MSG.error("Failed to load Whisper model: %s", e)
        self._whisper = None
        return False














parakit


1. Create engine/sttgstparakeet.py
import logging
import threading
import queue
import numpy as np
import re

from pathlib import Path
from gi.repository import Gst, GLib
from sttutils import *
from sttgstbase import STTGstBase
from sttcurrentlocale import stt_current_locale
from sttparakeetmodel import STTParakeetModel

LOG_MSG = logging.getLogger()
SPECIAL_PATTERN = re.compile(r'^(?:\[[^\]]+\]|\([^)]+\))$', re.IGNORECASE)

try:
    import nemo.collections.asr as nemo_asr
    PARAKEET_AVAILABLE = True
except ImportError:
    LOG_MSG.warning("NeMo not available. Install with: pip install nemo_toolkit[asr]")
    PARAKEET_AVAILABLE = False


class STTGstParakeet(STTGstBase):
    __gtype_name__ = 'STTGstParakeet'
    _pipeline_def = "pulsesrc blocksize=3200 buffer-time=9223372036854775807 ! " \
                    "audio/x-raw,format=S16LE,rate=16000,channels=1 ! " \
                    "webrtcdsp noise-suppression-level=3 echo-cancel=false ! " \
                    "queue ! " \
                    "appsink name=ParakeetSink emit-signals=true sync=false"

    _pipeline_def_alt = "pulsesrc blocksize=3200 buffer-time=9223372036854775807 ! " \
                        "audio/x-raw,format=S16LE,rate=16000,channels=1 ! " \
                        "queue ! " \
                        "appsink name=ParakeetSink emit-signals=true sync=false"

    def __init__(self, current_locale=None):
        plugin = Gst.Registry.get().find_plugin("webrtcdsp")
        if plugin is not None:
            super().__init__(pipeline_definition=STTGstParakeet._pipeline_def)
            LOG_MSG.debug("using Webrtcdsp plugin")
        else:
            super().__init__(pipeline_definition=STTGstParakeet._pipeline_def_alt)
            LOG_MSG.debug("not using Webrtcdsp plugin")

        if self.pipeline is None:
            LOG_MSG.error("pipeline was not created")
            return

        self._appsink = self.pipeline.get_by_name("ParakeetSink")
        if self._appsink is None:
            LOG_MSG.error("no appsink element!")
            return

        self._appsink.connect("new-sample", self._on_new_sample)

        if current_locale is None:
            self._current_locale = stt_current_locale()
        else:
            self._current_locale = current_locale

        self._locale_id = self._current_locale.connect("changed", self._locale_changed)

        self._model_id = 0
        self._model = None
        self._parakeet = None
        self._set_model()

        self._audio_buffer = []
        self._buffer_duration = 0.0
        self._max_buffer_duration = 5.0
        self._min_buffer_duration = 1.5
        self._sample_rate = 16000
        self._processing = False
        self._process_queue = queue.Queue()
        self._process_thread = None
        self._stop_processing = False

        self._use_partial_results = False

    def __del__(self):
        LOG_MSG.info("Parakeet __del__")
        self._stop_processing = True
        if self._process_thread is not None:
            self._process_thread.join(timeout=2.0)
        super().__del__()

    def destroy(self):
        self._stop_processing = True
        if self._process_thread is not None:
            self._process_thread.join(timeout=2.0)

        self._current_locale.disconnect(self._locale_id)
        self._locale_id = 0

        if self._model_id != 0:
            self._model.disconnect(self._model_id)
            self._model_id = 0

        self._appsink = None
        self._parakeet = None

        LOG_MSG.info("Parakeet.destroy() called")
        super().destroy()

    def _load_parakeet_model(self, model_path):
        """Load Parakeet model using NeMo"""
        if not PARAKEET_AVAILABLE:
            LOG_MSG.error("NeMo not available")
            return False

        try:
            LOG_MSG.info("Loading Parakeet model: %s", model_path)
            
            # Load the ASR model
            self._parakeet = nemo_asr.models.EncDecRNNTBPEModel.restore_from(model_path)
            
            # Set model to eval mode
            self._parakeet.eval()
            
            # Freeze model for inference
            self._parakeet.freeze()
            
            LOG_MSG.info("Parakeet model loaded successfully")
            return True
            
        except Exception as e:
            LOG_MSG.error("Failed to load Parakeet model: %s", e)
            self._parakeet = None
            return False

    def _set_model_path(self):
        if self._model is None or self._model.available() is False:
            LOG_MSG.info("model path does not exist (%s - %s)",
                        self._model.get_name() if self._model else "None",
                        self._model.get_path() if self._model else "None")
            self._parakeet = None
            self.emit("model-changed")
            return

        new_model_path = self._model.get_path()
        LOG_MSG.debug("model ready %s", new_model_path)

        # Load the model
        ret, state, pending = self.pipeline.get_state(0)
        if state >= Gst.State.READY:
            self.pipeline.set_state(Gst.State.READY)

        success = self._load_parakeet_model(new_model_path)

        if state >= Gst.State.READY:
            self.pipeline.set_state(state)

        if success:
            self.emit("model-changed")

    def _model_changed(self, model):
        self._set_model_path()

    def _set_model(self):
        if self._model is not None and \
           self._model.get_locale() == self._current_locale.locale:
            return

        if self._model_id != 0:
            self._model.disconnect(self._model_id)
            self._model_id = 0

        self._model = STTParakeetModel(locale_str=self._current_locale.locale)
        self._model_id = self._model.connect("changed", self._model_changed)
        self._set_model_path()

    def _locale_changed(self, locale):
        self._set_model()

    def _on_new_sample(self, appsink):
        """Callback when new audio sample arrives"""
        sample = appsink.emit("pull-sample")
        if sample is None:
            return Gst.FlowReturn.OK

        buf = sample.get_buffer()
        success, map_info = buf.map(Gst.MapFlags.READ)
        if not success:
            return Gst.FlowReturn.OK

        audio_data = np.frombuffer(map_info.data, dtype=np.int16)
        buf.unmap(map_info)

        self._audio_buffer.append(audio_data)
        self._buffer_duration += len(audio_data) / self._sample_rate

        if self._buffer_duration >= self._max_buffer_duration:
            self._process_audio_buffer()

        return Gst.FlowReturn.OK

    def _process_audio_buffer(self):
        """Process accumulated audio buffer"""
        if len(self._audio_buffer) == 0:
            return

        if self._buffer_duration < self._min_buffer_duration:
            LOG_MSG.debug("Buffer too short (%.2fs), waiting for more audio", self._buffer_duration)
            return

        if self._parakeet is None:
            LOG_MSG.warning("Parakeet model not loaded")
            self._audio_buffer.clear()
            self._buffer_duration = 0.0
            return

        audio = np.concatenate(self._audio_buffer)
        self._audio_buffer.clear()
        self._buffer_duration = 0.0

        LOG_MSG.debug("Processing audio buffer: %d samples (%.2f seconds)", 
                     len(audio), len(audio) / self._sample_rate)

        audio_float = audio.astype(np.float32) / 32768.0

        self._process_queue.put(audio_float)

        if self._process_thread is None or not self._process_thread.is_alive():
            self._process_thread = threading.Thread(target=self._process_worker, daemon=True)
            self._process_thread.start()

    def _process_worker(self):
        """Background worker to process audio"""
        while not self._stop_processing:
            try:
                audio = self._process_queue.get(timeout=0.1)
            except queue.Empty:
                continue

            if self._parakeet is None:
                self._process_queue.task_done()
                continue

            try:
                LOG_MSG.debug("Starting transcription of %d samples", len(audio))
                
                # Convert to tensor format expected by NeMo
                import torch
                audio_tensor = torch.from_numpy(audio).unsqueeze(0)
                audio_len = torch.tensor([len(audio)])
                
                # Transcribe
                with torch.no_grad():
                    hypotheses = self._parakeet.transcribe(
                        audio=audio_tensor,
                        audio_len=audio_len,
                        return_hypotheses=False
                    )
                
                if isinstance(hypotheses, list) and len(hypotheses) > 0:
                    text = hypotheses[0]
                elif isinstance(hypotheses, str):
                    text = hypotheses
                else:
                    text = ""
                
                text = text.strip()
                
                # Filter out special tokens
                if SPECIAL_PATTERN.match(text):
                    text = ""

                if text:
                    LOG_MSG.info("Parakeet transcription result: '%s'", text)
                    GLib.idle_add(self._emit_text, text)
                else:
                    LOG_MSG.debug("No text transcribed from audio")

            except Exception as e:
                LOG_MSG.error("Parakeet transcription error: %s", e, exc_info=True)

            self._process_queue.task_done()

    def _emit_text(self, text):
        self.emit("text", text)
        return False

    def get_final_results(self):
        if len(self._audio_buffer) > 0:
            self._process_audio_buffer()
        self._process_queue.join()

    def get_results(self):
        pass

    def set_use_partial_results(self, active):
        self._use_partial_results = active

    def set_alternatives_num(self, num):
        pass

    def has_model(self):
        if self._model is None or self._model.available() is False:
            return False
        return super().has_model()

    def _stop_real(self):
        self.get_final_results()
        return super()._stop_real()




2. Create engine/sttparakeetmodel.py
import json
import logging

from pathlib import Path
from gi.repository import GObject, Gio
from sttparakeetmodelmanagers import stt_parakeet_local_model_manager

LOG_MSG = logging.getLogger()

class STTParakeetModel(GObject.Object):
    __gtype_name__ = "STTParakeetModel"
    __gsignals__ = {
        "changed": (GObject.SIGNAL_RUN_FIRST, None, ()),
    }

    def __init__(self, locale_str=None):
        super().__init__()

        self._locale_str = locale_str
        self._settings = Gio.Settings.new("org.freedesktop.ibus.engine.stt")
        self._settings_id = self._settings.connect("changed::parakeet-models", self._models_changed)

        self._model_name = None
        self._model_path = None
        self._valid_model = False

        model = self._get_model_from_settings()
        self._set_model(model)

        self._model_path_added_id = stt_parakeet_local_model_manager().connect("added", self._model_added_cb)
        self._model_path_removed_id = stt_parakeet_local_model_manager().connect("removed", self._model_removed_cb)

    def __del__(self):
        stt_parakeet_local_model_manager().disconnect(self._model_path_added_id)
        stt_parakeet_local_model_manager().disconnect(self._model_path_removed_id)
        if self._model_name is None and self._model_path is not None:
            stt_parakeet_local_model_manager().unregister_custom_model_path(self._model_path)

    def _get_model_from_settings(self):
        models_json_string = self._settings.get_string("parakeet-models")
        if models_json_string in (None, "None", ""):
            return None

        models_dict = json.loads(models_json_string)
        return models_dict.get(self._locale_str, None)

    def _set_model(self, model):
        LOG_MSG.debug("new model (%s, current path=%s / current name=%s)",
                     model, self._model_path, self._model_name)
        if model is None:
            if self._model_name is None and self._model_path is None:
                return

            self._model_name = None
            self._model_path = None
            self._valid_model = False

            self.emit("changed")
            return

        model = model.rstrip("/")
        model_name = self._model_name
        model_path = self._model_path

        if Path(model).is_absolute() is True:
            if self._model_name is None and self._model_path == model:
                return

            self._model_name = None
            self._model_path = model
            stt_parakeet_local_model_manager().register_custom_model_path(model, self._locale_str)
            self._valid_model = stt_parakeet_local_model_manager().path_available(model)
        else:
            tmp_model_path = stt_parakeet_local_model_manager().get_best_path_for_model(model)
            if self._model_name == model and tmp_model_path == model_path:
                return

            self._model_name = model
            self._model_path = tmp_model_path
            self._valid_model = bool(tmp_model_path is not None)

        if model_path not in [self._model_path, None] and model_name is None:
            stt_parakeet_local_model_manager().unregister_custom_model_path(model_path)

        LOG_MSG.debug("model changed (valid=%i, current path=%s - current name=%s)",
                     self._valid_model, self._model_path, self._model_name)
        self.emit("changed")

    def _models_changed(self, settings, key):
        model = self._get_model_from_settings()
        self._set_model(model)

    def _model_added_cb(self, manager, name, path):
        if self._model_name is not None:
            if name != self._model_name:
                return

            model_path = stt_parakeet_local_model_manager().get_best_path_for_model(name)
            if self._model_path == model_path:
                return

            self._model_path = model_path
        elif self._model_path != path:
            return

        self._valid_model = True
        self.emit("changed")

    def _model_removed_cb(self, manager, name, path):
        if self._model_name is not None:
            if name != self._model_name:
                return

            if self._model_path != path:
                return

            self._model_path = stt_parakeet_local_model_manager().get_best_path_for_model(name)
            self._valid_model = bool(self._model_path is not None)
        elif self._model_path == path:
            self._valid_model = False
        else:
            return

        self.emit("changed")

    def available(self):
        return self._valid_model

    def get_locale(self):
        return self._locale_str

    def get_name(self):
        return self._model_name

    def get_path(self):
        return self._model_path

    def set_name(self, model_name):
        self._set_model(model_name)

        models_json_string = self._settings.get_string("parakeet-models")
        if models_json_string in (None, "None", ""):
            models_dict = {}
        else:
            models_dict = json.loads(models_json_string)

        models_dict[self._locale_str] = model_name
        models_json_string = json.dumps(models_dict)

        self._settings.disconnect(self._settings_id)
        self._settings.set_string("parakeet-models", models_json_string)
        self._settings_id = self._settings.connect("changed::parakeet-models", self._models_changed)





3. Create engine/sttparakeetmodelmanagers.py


import os
import json
import logging
from pathlib import Path
import urllib.request
from enum import Enum
import tempfile
import shutil
import uuid
import threading

from gi.repository import GObject, Gio, GLib

LOG_MSG = logging.getLogger()

# Parakeet model directories
MODEL_DIRS = [
    os.getenv('PARAKEET_MODEL_PATH'),
    Path.home() / '.cache/parakeet',
    Path('/usr/share/parakeet'),
    Path('/usr/local/share/parakeet')
]

# HuggingFace model repository
MODEL_PRE_URL = 'https://huggingface.co/nvidia/'
PARAKEET_MODELS = {
    'parakeet-tdt-0.6b': 'parakeet-tdt-0.6b',
    'parakeet-tdt-0.6b-v2': 'parakeet-tdt-0.6b-v2',
    'parakeet-tdt-1.1b': 'parakeet-tdt-1.1b',
}

DOWNLOADED_MODEL_SUFFIX = ".downloaded_model_tmp"

def _helper_locale_normalize(locale_str):
    lang = locale_str[0:2].lower()
    if len(locale_str) < 5:
        return lang
    lang2 = locale_str[3:5]
    return lang + "_" + lang2.upper()

class STTDownloadState(float, Enum):
    STOPPED = -1.0
    UNKNOWN_PROGRESS = -0.5
    UNPACKING = -0.6
    ONGOING = 0.0

class STTParakeetModelDescription(GObject.Object):
    __gtype_name__ = "STTParakeetModelDescription"

    def __init__(self, init_model=None):
        super().__init__()
        self.name = init_model.name if init_model is not None else ""
        self.custom = init_model.custom if init_model is not None else False
        self.is_obsolete = False
        self.paths = init_model.paths if init_model is not None else []
        self.size = init_model.size if init_model is not None else ""
        self.type = init_model.type if init_model is not None else ""
        self.locale = init_model.locale if init_model is not None else "multilingual"
        self.url = init_model.url if init_model is not None else ""

        self._operation = None
        self.download_progress = STTDownloadState.STOPPED

    def _download_finished(self):
        if self._operation.is_cancelled():
            self._operation = None

    def _download_model_thread(self, download_link, destination, status):
        """Download model from HuggingFace using git"""
        try:
            import subprocess
            
            # Create destination parent directory
            destination.parent.mkdir(parents=True, exist_ok=True)
            
            # Use huggingface-cli to download
            LOG_MSG.info("Downloading model from HuggingFace: %s", download_link)
            
            # Extract repo name from URL
            repo_name = download_link.replace(MODEL_PRE_URL, '')
            
            # Download using huggingface-cli
            cmd = [
                'huggingface-cli', 'download',
                f'nvidia/{repo_name}',
                '--local-dir', str(destination),
                '--local-dir-use-symlinks', 'False'
            ]
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            while True:
                if status.is_cancelled():
                    process.terminate()
                    if destination.exists():
                        shutil.rmtree(destination)
                    return
                
                output = process.stdout.readline()
                if output == '' and process.poll() is not None:
                    break
                    
                if output:
                    LOG_MSG.debug("Download output: %s", output.strip())
                    # Try to extract progress if available
                    self.download_progress = STTDownloadState.UNKNOWN_PROGRESS
            
            if process.returncode == 0:
                LOG_MSG.info("Model downloaded successfully")
            else:
                error = process.stderr.read()
                LOG_MSG.error("Download failed: %s", error)
                if destination.exists():
                    shutil.rmtree(destination)
                    
        except Exception as e:
            LOG_MSG.error("Download error: %s", e)
            if destination.exists():
                shutil.rmtree(destination)

        self.download_progress = STTDownloadState.STOPPED
        GLib.idle_add(self._download_finished)

    def stop_downloading(self):
        if self._operation is not None:
            self._operation.cancel()

    def start_downloading(self):
        if self._operation is not None:
            return

        LOG_MSG.debug("start downloading model (%s)", self.url)

        self.download_progress = STTDownloadState.ONGOING
        self._operation = Gio.Cancellable()

        download_thread = threading.Thread(
            target=self._download_model_thread,
            args=(self.url, Path(MODEL_DIRS[1], self.name), self._operation)
        )
        download_thread.start()

    def get_best_path_for_model(self):
        if self.paths in [None, []]:
            return None
        return self.paths[0]

    def delete_paths(self):
        if self.custom is True:
            return

        for path in self.paths:
            if Path(path).parent == MODEL_DIRS[1] and self.url is not None:
                try:
                    shutil.rmtree(path)
                except Exception as e:
                    LOG_MSG.error("Failed to delete %s: %s", path, e)

        self._operation = None
        self.download_progress = STTDownloadState.STOPPED
        self.paths = []

class STTParakeetLocalModelManager(GObject.Object):
    __gtype_name__ = "STTParakeetLocalModelManager"

    __gsignals__ = {
        "added": (GObject.SIGNAL_RUN_FIRST, None, (str, str,)),
        "removed": (GObject.SIGNAL_RUN_FIRST, None, (str, str,)),
    }

    def __init__(self):
        super().__init__()
        self._monitors = []
        self._models_dict = {}
        self._locales_dict = {}
        self._model_paths_dict = {}
        self._get_available_local_models()
        self._custom_paths = {}

    def _add_model_description_to_locale(self, model_desc):
        if model_desc.locale is None:
            return

        models_list = self._locales_dict.get(model_desc.locale, None)
        if models_list is None:
            self._locales_dict[model_desc.locale] = [model_desc]
        else:
            models_list.append(model_desc)

    def _new_model_available(self, model_path):
        if str(model_path).endswith(DOWNLOADED_MODEL_SUFFIX):
            LOG_MSG.debug("model path is a temporary directory (%s)", model_path)
            return None

        if not model_path.is_dir():
            LOG_MSG.debug("model path is not a directory (%s)", model_path)
            return None

        # Check if it's a valid NeMo model directory (has .nemo file or model config)
        has_nemo_file = any(model_path.glob('*.nemo'))
        has_config = (model_path / 'model_config.yaml').exists()
        
        if not (has_nemo_file or has_config):
            LOG_MSG.debug("model path doesn't contain NeMo model files (%s)", model_path)
            return None

        if not os.access(model_path, os.R_OK):
            LOG_MSG.debug("access rights are wrong (%s)", model_path)
            return None

        if self.path_available(str(model_path)):
            LOG_MSG.debug("model directory already in list (%s)", model_path)
            return None

        locale_str = "multilingual"  # Parakeet models are multilingual
        model_type = None
        model_name = model_path.name

        if model_path.parent not in MODEL_DIRS:
            model_desc = STTParakeetModelDescription()
            model_desc.paths = [str(model_path)]
            model_desc.name = model_name
            model_desc.custom = True
            model_desc.locale = locale_str
            model_desc.type = model_type

            self._models_dict[str(model_path)] = model_desc
            self._model_paths_dict[str(model_path)] = model_desc

            LOG_MSG.debug("custom model directory is valid (%s)", model_path)
            return model_desc

        model_desc = self._models_dict.get(model_name, None)
        if model_desc is None:
            model_desc = STTParakeetModelDescription()
            model_desc.paths = [str(model_path)]
            model_desc.locale = locale_str
            model_desc.type = model_type
            model_desc.name = model_name

            self._add_model_description_to_locale(model_desc)
            self._models_dict[model_desc.name] = model_desc
            self._model_paths_dict[str(model_path)] = model_desc

            LOG_MSG.debug("model directory is valid (%s) - name not known yet", model_path)
            self.emit("added", model_name, str(model_path))
            return model_desc

        model_desc.paths.append(str(model_path))
        model_desc.paths.sort(key=lambda element: MODEL_DIRS.index(Path(element).parent))

        LOG_MSG.debug("model directory is valid (%s) - name already known", model_path)
        self.emit("added", model_name, str(model_path))
        return model_desc

    def _remove_model_description(self, model_path):
        model_desc = self._model_paths_dict.pop(model_path, None)
        if model_desc is None:
            return

        LOG_MSG.debug("model directory removed (%s)", model_path)

        model_desc.paths.remove(model_path)
        if not any(model_desc.paths):
            models_list = self._locales_dict.get(model_desc.locale, [])
            if model_desc in models_list:
                models_list.remove(model_desc)
            if not any(models_list):
                self._locales_dict.pop(model_desc.locale, None)

            key = model_desc.name if model_desc.custom is False else model_path
            self._models_dict.pop(key, None)

        model_name = model_desc.name if model_desc.custom is False else None
        self.emit("removed", model_name, model_path)

    def _model_file_changed_cb(self, monitor, file, other_file, event_type):
        LOG_MSG.debug("a file changed (source = %s) %s %s", self, file.get_path(), event_type)

        if file.get_path() in [str(d) for d in MODEL_DIRS if d]:
            LOG_MSG.debug("change does not concern a child of a top directory. Ignoring.")
            return

        LOG_MSG.info("a model file changed (%s) (event=%s)", file.get_path(), event_type)
        if event_type == Gio.FileMonitorEvent.CHANGES_DONE_HINT:
            if file.get_path().endswith(DOWNLOADED_MODEL_SUFFIX):
                LOG_MSG.debug("temporary directory ignored (%s)", file.get_path())
                return

            self._new_model_available(Path(file.get_path()))
        elif event_type == Gio.FileMonitorEvent.DELETED:
            self._remove_model_description(file.get_path())

    def _get_available_local_models(self):
        for directory in MODEL_DIRS:
            LOG_MSG.debug("scanning %s for models", directory)

            if directory is None:
                continue

            monitor = Gio.File.new_for_path(str(directory)).monitor(Gio.FileMonitorFlags.NONE, None)
            monitor.connect("changed", self._model_file_changed_cb)
            self._monitors.append(monitor)

            directory_path = Path(directory)
            if not directory_path.is_dir():
                continue

            for child in directory_path.iterdir():
                LOG_MSG.debug("scanning directory (%s)", str(child))
                self._new_model_available(child)

    def path_available(self, model_path):
        return model_path in self._model_paths_dict

    def get_models_for_locale(self, locale_str):
        # Parakeet models are multilingual, so return all for any locale
        return list(self._models_dict.values())

    def get_best_path_for_model(self, model_name):
        if model_name is None:
            return None

        model = self._models_dict.get(model_name, None)
        if model is None:
            return None

        if model.paths in [None, []]:
            return None

        return model.paths[0]

    def get_model_description(self, model_name):
        return self._models_dict.get(model_name, None)

    def get_supported_locales(self):
        return list(self._locales_dict.keys())

    def _custom_model_file_changed_cb(self, monitor, file, other_file, event_type):
        LOG_MSG.info("a custom model file changed (%s) (event=%s)", file.get_path(), event_type)
        if event_type == Gio.FileMonitorEvent.CHANGES_DONE_HINT:
            self._new_model_available(Path(file.get_path()))
        elif event_type == Gio.FileMonitorEvent.DELETED:
            model = self._model_paths_dict.get(file.get_path(), None)
            if model is None:
                return

            LOG_MSG.debug("custom model directory removed (%s)", file.get_path())
            self._model_paths_dict.pop(file.get_path(), None)
            self.emit("removed", None, file.get_path())

    def register_custom_model_path(self, model_path_str, locale_str):
        if Path(model_path_str).parent in MODEL_DIRS:
            LOG_MSG.debug("registered a path in default directories (%s)", model_path_str)
            return

        monitor = self._custom_paths.get(model_path_str, None)
        if monitor is not None:
            monitor.refcount += 1
            LOG_MSG.debug("custom path already registered (%s). Increasing refcount (%i).",
                         model_path_str, monitor.refcount)
            return

        monitor = Gio.File.new_for_path(model_path_str).monitor_file(Gio.FileMonitorFlags.NONE, None)
        monitor.connect("changed", self._custom_model_file_changed_cb)
        self._custom_paths[model_path_str] = monitor
        monitor.refcount = 1

        model_desc = self._new_model_available(Path(model_path_str))
        if model_desc:
            model_desc.locale = locale_str
            self._add_model_description_to_locale(model_desc)
            self.emit("added", None, model_path_str.rstrip("/"))

    def unregister_custom_model_path(self, model_path_str):
        monitor = self._custom_paths.get(model_path_str, None)
        if monitor is None:
            LOG_MSG.debug("trying to unregister a path not in custom model paths (%s)", model_path_str)
            return

        if monitor.refcount != 1:
            LOG_MSG.debug("refcount of custom path not 0 yet (%s)", model_path_str)
            monitor.refcount -= 1
            return

        self._custom_paths.pop(model_path_str, None)
        self._remove_model_description(model_path_str)

_GLOBAL_LOCAL_MANAGER = None

def stt_parakeet_local_model_manager():
    global _GLOBAL_LOCAL_MANAGER
    if _GLOBAL_LOCAL_MANAGER is None:
        _GLOBAL_LOCAL_MANAGER = STTParakeetLocalModelManager()
    return _GLOBAL_LOCAL_MANAGER

class STTParakeetOnlineModelManager(GObject.Object):
    __gtype_name__ = "STTParakeetOnlineModelManager"
    __gsignals__ = {
        "added": (GObject.SIGNAL_RUN_FIRST, None, (object,)),
        "changed": (GObject.SIGNAL_RUN_FIRST, None, (object,)),
        "removed": (GObject.SIGNAL_RUN_FIRST, None, (object,)),
    }

    def __init__(self):
        super().__init__()

        self._locales_dict = {}
        self._online_models = {}

        local_manager = stt_parakeet_local_model_manager()
        local_manager.connect("added", self._model_path_added_cb)
        local_manager.connect("removed", self._model_path_removed_cb)
        self._populate_with_parakeet_models()

    def _populate_with_parakeet_models(self):
        model_sizes = {
            'parakeet-tdt-0.6b': '~600 MB',
            'parakeet-tdt-0.6b-v2': '~600 MB',
            'parakeet-tdt-1.1b': '~1.1 GB',
        }

        for model_name, repo_name in PARAKEET_MODELS.items():
            model_desc = STTParakeetModelDescription()
            model_desc.name = repo_name
            model_desc.url = MODEL_PRE_URL + repo_name
            model_desc.size = model_sizes.get(model_name, 'Unknown')
            model_desc.locale = 'multilingual'
            model_desc.type = model_name

            LOG_MSG.debug("adding online model (%s)", model_desc.name)

            local_desc = stt_parakeet_local_model_manager().get_model_description(model_desc.name)
            if local_desc is not None:
                model_desc.paths = local_desc.paths

            self._online_models[model_desc.name] = model_desc
            self._add_model_description_to_locale(model_desc)

        # Add local custom models
        for locale in stt_parakeet_local_model_manager().get_supported_locales():
            model_list = stt_parakeet_local_model_manager().get_models_for_locale(locale)
            LOG_MSG.debug("adding local models for locale (%s)", locale)
            for model_desc in model_list:
                key = model_desc.name if model_desc.custom is False else model_desc.paths[0]
                if key in self._online_models:
                    continue

                LOG_MSG.debug("adding local model to online dict (%s)", key)
                self._online_models[key] = model_desc
                self._add_model_description_to_locale(model_desc)

    def _add_model_description_to_locale(self, model_desc):
        locale_models = self._locales_dict.get(model_desc.locale, None)
        if locale_models is None:
            self._locales_dict[model_desc.locale] = [model_desc]
        else:
            locale_models.append(model_desc)

    def _model_path_added_cb(self, manager, model_name, model_path):
        if model_name is not None:
            online_model_desc = self._online_models.get(model_name, None)
            local_model_desc = manager.get_model_description(model_name)
        else:
            online_model_desc = self._online_models.get(model_path, None)
            local_model_desc = manager.get_model_description(model_path)

        if online_model_desc is not None:
            if online_model_desc.paths in [None, []]:
                online_model_desc.paths = local_model_desc.paths
            self.emit("changed", online_model_desc)
            return

        key = local_model_desc.name if local_model_desc.custom is False else local_model_desc.paths[0]
        self._online_models[key] = local_model_desc
        self._add_model_description_to_locale(local_model_desc)
        self.emit("added", local_model_desc)

    def _remove_model_description_from_locale(self, model_desc):
        locale_models = self._locales_dict.get(model_desc.locale, None)
        if locale_models and model_desc in locale_models:
            locale_models.remove(model_desc)
        if not any(locale_models):
            self._locales_dict.pop(model_desc.locale, None)

    def _model_path_removed_cb(self, manager, model_name, model_path):
        if model_name is None:
            online_model_desc = self._online_models.pop(model_path, None)
            if online_model_desc:
                self._remove_model_description_from_locale(online_model_desc)
                self.emit("removed", online_model_desc)
            return

        online_model_desc = self._online_models.get(model_name, None)
        if online_model_desc is None:
            return

        if any(online_model_desc.paths):
            self.emit("changed", online_model_desc)
            return

        if online_model_desc.url is not None:
            self.emit("changed", online_model_desc)
            return

        self._online_models.pop(model_name, None)
        self._remove_model_description_from_locale(online_model_desc)
        self.emit("removed", online_model_desc)

    def get_model_description(self, model_name):
        return self._online_models.get(model_name, None)

    def get_models_for_locale(self, locale_str):
        # Parakeet is multilingual, return all models for any locale
        all_models = []
        for models in self._locales_dict.values():
            all_models.extend(models)
        return all_models

    def supported_locales(self):
        return list(self._locales_dict.keys())

_GLOBAL_ONLINE_MANAGER = None

def stt_parakeet_online_model_manager():
    global _GLOBAL_ONLINE_MANAGER
    if _GLOBAL_ONLINE_MANAGER is None:
        _GLOBAL_ONLINE_MANAGER = STTParakeetOnlineModelManager()
    return _GLOBAL_ONLINE_MANAGER



5. Update engine/sttconfigdialog.ui

<object class="GtkStringList" id="backend_list">
  <items>
    <item translatable="yes">Vosk</item>
    <item translatable="yes">Whisper</item>
    <item translatable="yes">Parakeet</item>
  </items>
</object>




6. Update engine/sttconfigdialog.py

# Add import at top
from sttparakeetmodelmanagers import stt_parakeet_online_model_manager

# In __init__ method, update backend initialization
backend = self._settings.get_string("backend")
if backend == "parakeet":
    self.backend_dropdown.set_selected(2)
elif backend == "whisper":
    self.backend_dropdown.set_selected(1)
else:
    self.backend_dropdown.set_selected(0)

# Update backend_dropdown_selected_cb
@Gtk.Template.Callback()
def backend_dropdown_selected_cb(self, dropdown, param):
    selected = dropdown.get_selected()
    if selected == 0:
        backend = "vosk"
    elif selected == 1:
        backend = "whisper"
    else:
        backend = "parakeet"
    
    current_backend = self._settings.get_string("backend")
    if backend != current_backend:
        self._settings.set_string("backend", backend)
        self._reload_locale_rows()

# Add initialization in __init__
stt_parakeet_online_model_manager()




7. Update engine/sttlocalerow.py

# Add import
from sttparakeetmodel import STTParakeetModel
from sttparakeetmodelmanagers import stt_parakeet_online_model_manager

# Update _init_model method
def _init_model(self):
    backend = self._settings.get_string("backend")
    if backend == "parakeet":
        self._model = STTParakeetModel(locale_str=self._locale)
    elif backend == "whisper":
        self._model = STTWhisperModel(locale_str=self._locale)
    else:
        self._model = STTVoskModel(locale_str=self._locale)
    
    self._model.connect("changed", self._model_changed)
    self.update_description()

# Update update_description method
def update_description(self):
    if self._model.available() == False:
        self.set_subtitle(_("No model downloaded yet"))
        return

    model_name = self._model.get_name()
    if model_name in [None, ""]:
        model_path = self._model.get_path()
        if model_path and model_path != "":
            self.set_subtitle(_("Custom model: %s") % model_path)
        else:
            self.set_subtitle(_("Custom model installed manually in a non-standard directory"))
        return

    backend = self._settings.get_string("backend")
    if backend == "parakeet":
        manager = stt_parakeet_online_model_manager()
    elif backend == "whisper":
        manager = stt_whisper_online_model_manager()
    else:
        manager = stt_vosk_online_model_manager()
    
    model = manager.get_model_description(model_name)
    # ... rest of the method



8. Update engine/sttmodelchooserdialog.py

# Add imports
from sttparakeetmodelmanagers import stt_parakeet_online_model_manager
from sttparakeetmodel import STTParakeetModel

# Update __init__ to detect Parakeet
self._is_parakeet = isinstance(model, STTParakeetModel)
if self._is_parakeet:
    self._manager = stt_parakeet_online_model_manager()
elif self._is_whisper:
    self._manager = stt_whisper_online_model_manager()
else:
    self._manager = stt_vosk_online_model_manager()

# Update dialog title
if self._is_parakeet:
    backend_name = "Parakeet"
elif self._is_whisper:
    backend_name = "Whisper"
else:
    backend_name = "Vosk"
self.set_title(_("Manage %s Recognition Models") % backend_name)

# Update file chooser logic
if self._is_parakeet:
    action = Gtk.FileChooserAction.SELECT_FOLDER
    title = _("Open Parakeet Model Folder")
elif self._is_whisper:
    action = Gtk.FileChooserAction.OPEN
    title = _("Open Whisper Model File")
else:
    action = Gtk.FileChooserAction.SELECT_FOLDER
    title = _("Open Vosk Model Folder")






9. Update data/org.freedesktop.ibus.engine.stt.gschema.xml.in

<!-- Add after whisper-models key -->
<key type="s" name="parakeet-models">
  <summary>Paths to Parakeet models</summary>
  <default>'None'</default>
  <description>A JSON formatted string that is used to associate locales with their Parakeet models. It can be the name of a model if it is in default monitored paths or a custom path.</description>
</key>





10. Update engine/meson.build

stt_sources = [
    'main.py',
    'mainconfig.py',
    'sttenginefactory.py',
    'sttengine.py',
    'sttgstvosk.py',
    'sttgstwhisper.py',
    'sttgstparakeet.py',  # Add this
    'sttgstfactory.py',
    'sttgstbase.py',
    'sttsegmentprocess.py',
    'sttconfigdialog.py',
    'sttlocalerow.py',
    'sttvoskmodel.py',
    'sttwhispermodel.py',
    'sttparakeetmodel.py',  # Add this
    'sttcurrentlocale.py',
    'sttutterancetree.py',
    'sttshortcutrow.py',
    'sttshortcutdialog.py',
    'sttutterancerow.py',
    'sttmodelchooserdialog.py',
    'sttvoskmodelmanagers.py',
    'sttwhispermodelmanagers.py',
    'sttparakeetmodelmanagers.py',  # Add this
    'sttwordstodigits.py',
    'sttmodelrow.py'
]












----- Sttmodelchooserdialog.py

import logging

from gettext import gettext as _

import gi

gi.require_version('Gtk', '4.0')

from gi.repository import Gtk, Gio

from sttmodelrow import STTModelRow
from sttvoskmodelmanagers import stt_vosk_online_model_manager
from sttwhispermodelmanagers import stt_whisper_online_model_manager
from sttparakeetmodelmanagers import stt_parakeet_online_model_manager
from sttwhispermodel import STTWhisperModel
from sttparakeetmodel import STTParakeetModel

LOG_MSG=logging.getLogger()

def _helper_merge_online_choices(models_dict, online_models):
    for model in online_models:
        local_model=models_dict.get(model.name, None)
        if local_model is not None:
            local_model.url=model.url
            local_model.size=model.size
            local_model.type=model.type
            local_model.is_obsolete=model.is_obsolete
        else:
            models_dict[model.name]=model

@Gtk.Template(resource_path="/org/freedesktop/ibus/engine/stt/config/sttmodelchooserdialog.ui")
class STTModelChooserDialog(Gtk.Dialog):
    __gtype_name__="STTModelChooserDialog"

    model_list=Gtk.Template.Child()
    obsolete_button=Gtk.Template.Child()

    def __init__(self, model=None, **kwargs):
        super().__init__(**kwargs)

        self._model_dict={}
        self._model=model

        self._is_parakeet = isinstance(model, STTParakeetModel)
        self._is_whisper = isinstance(model, STTWhisperModel)

        if self._is_parakeet:
            self._manager = stt_parakeet_online_model_manager()
        elif self._is_whisper:
            self._manager = stt_whisper_online_model_manager()
        else:
            self._manager = stt_vosk_online_model_manager()

        locale_str=model.get_locale()
        full_list=[]

        if self._is_parakeet:
            # Parakeet models are multilingual, just show all
            seen_models = set()
            for model_desc in self._manager.get_models_for_locale(locale_str):
                if model_desc.name not in seen_models:
                    seen_models.add(model_desc.name)
                    full_list.append(model_desc)
            # Also try lang prefix
            if len(locale_str) > 2:
                for model_desc in self._manager.get_models_for_locale(locale_str[:2]):
                    if model_desc.name not in seen_models:
                        seen_models.add(model_desc.name)
                        full_list.append(model_desc)
        elif self._is_whisper:
            seen_models = set()
            models_to_check = [locale_str]
            if len(locale_str) > 2:
                models_to_check.append(locale_str[:2])

            for loc in models_to_check:
                for model_desc in self._manager.get_models_for_locale(loc):
                    if model_desc.name not in seen_models:
                        seen_models.add(model_desc.name)
                        full_list.append(model_desc)
        else:
            full_list = self._manager.get_models_for_locale(locale_str)
            if len(locale_str) > 2:
                full_list += self._manager.get_models_for_locale(locale_str[:2])

        LOG_MSG.debug("%i available models for %s", len(full_list), locale_str)
        for model_desc in full_list:
            self._add_row(model_desc)

        self._added_id = self._manager.connect("added", self._model_path_added_cb)
        self._changed_id = self._manager.connect("changed", self._model_path_changed_cb)
        self._removed_id = self._manager.connect("removed", self._model_path_removed_cb)

        if self._is_parakeet:
            backend_name = "Parakeet"
        elif self._is_whisper:
            backend_name = "Whisper"
        else:
            backend_name = "Vosk"
        self.set_title(_("Manage %s Recognition Models") % backend_name)

    def _add_row(self, model_desc):
        other_row=next(iter(self._model_dict.values())) if any(self._model_dict.values()) else None
        row=STTModelRow(desc=model_desc, model=self._model, row=other_row)
        self._model_dict[id(model_desc)]=row

        if model_desc.is_obsolete == True and row.check_button.get_active() == False:
            row.set_visible(self.obsolete_button.get_active())

        self.model_list.add(row)

    def _model_path_added_cb(self, manager, model_desc):
        if model_desc.locale != self._model.get_locale():
            return

        self._add_row(model_desc)

    def _model_path_changed_cb(self, manager, model_desc):
        row=self._model_dict.get(id(model_desc), None)
        if row is not None:
            row.update_description()

    def _model_path_removed_cb(self, manager, model_desc):
        row=self._model_dict.get(id(model_desc), None)
        if row is not None:
            self.model_list.remove(row)

    @Gtk.Template.Callback()
    def obsolete_button_toggled_cb(self, button):
        show_obsolete=button.get_active()
        for row in self._model_dict.values():
            if row.get_desc().is_obsolete == True and row.check_button.get_active() == False:
                row.set_visible(show_obsolete)

    def _open_locale_file_cb(self, dialog, response):
        if response != Gtk.ResponseType.ACCEPT:
            dialog.destroy()
            return

        file=dialog.get_file()
        dialog.destroy()
        self._model.set_name(file.get_path())

    @Gtk.Template.Callback()
    def new_model_button_clicked_cb(self, button):
        root_widget=self.get_root()
        if self._is_parakeet:
            action = Gtk.FileChooserAction.SELECT_FOLDER
            title = _("Open Parakeet Model Folder")
        elif self._is_whisper:
            action = Gtk.FileChooserAction.OPEN
            title = _("Open Whisper Model File")
        else:
            action = Gtk.FileChooserAction.SELECT_FOLDER
            title = _("Open Vosk Model Folder")

        dialog = Gtk.FileChooserDialog(transient_for=root_widget, title=title, modal=True, action=action)
        dialog.add_buttons(_("Cancel"), Gtk.ResponseType.CANCEL, _("Open"), Gtk.ResponseType.ACCEPT)
        dialog.connect("response", self._open_locale_file_cb)
        dialog.set_transient_for(root_widget)
        dialog.present()


---Sttlocalerow 

import locale
import logging

from gettext import gettext as _

from babel import Locale, UnknownLocaleError

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')

from gi.repository import Gtk, Adw, Gio

from sttutils import *

from sttvoskmodel import STTVoskModel
from sttwhispermodel import STTWhisperModel
from sttparakeetmodel import STTParakeetModel
from sttmodelchooserdialog import STTModelChooserDialog
from sttvoskmodelmanagers import stt_vosk_online_model_manager
from sttwhispermodelmanagers import stt_whisper_online_model_manager
from sttparakeetmodelmanagers import stt_parakeet_online_model_manager


LOG_MSG=logging.getLogger()

@Gtk.Template(resource_path="/org/freedesktop/ibus/engine/stt/config/sttlocalerow.ui")
class STTLocaleRow(Adw.ActionRow):
    __gtype_name__="STTLocaleRow"

    check_button = Gtk.Template.Child()

    def __init__(self, current_locale=None, locale_str=None, radio_group=None):
        super().__init__()
        if locale_str == None:
            LOG_MSG.error("no locale provided")
            return

        self._locale=locale_str
        system_locale_str=locale.getlocale()[0]
        try:
            babel_locale=Locale.parse(locale_str)
            name=babel_locale.get_display_name(system_locale_str)
        except UnknownLocaleError:
            name=locale_str

        if system_locale_str == self._locale:
            name = _("%s : system locale") % name

        self.set_title(name)

        self._current_locale = current_locale

        self._update_checked()
        self._current_locale.connect("changed", self._locale_changed)
        # Get current backend from settings
        self._settings = Gio.Settings.new("org.freedesktop.ibus.engine.stt")
        self._backend_changed_id = self._settings.connect("changed::backend", self._backend_changed_cb)
        # Initialize model based on current backend
        self._init_model()

    def _init_model(self):
        backend = self._settings.get_string("backend")
        if backend == "parakeet":
            self._model = STTParakeetModel(locale_str=self._locale)
        elif backend == "whisper":
            self._model = STTWhisperModel(locale_str=self._locale)
        else:
            self._model = STTVoskModel(locale_str=self._locale)

        self._model.connect("changed", self._model_changed)
        self.update_description()

    @property
    def locale(self):
        return self._locale

    @Gtk.Template.Callback()
    def check_button_toggled_cb(self, button):
        LOG_MSG.debug("check_button_toggled_cb (%s)", self._locale)
        if button.get_active() == self._current_locale.default_locale:
            return

        if button.get_active() == True:
            self._current_locale.locale=self._locale

    def _update_checked(self):
        is_current_locale=bool(self._current_locale.locale == self._locale)
        if self.check_button.get_active() != is_current_locale:
            self.check_button.set_active(is_current_locale)

    def _locale_changed(self, current_locale):
        self._update_checked()

    def _backend_changed_cb(self, settings, key):
        # Disconnect old model signal before reinitializing
        if hasattr(self, '_model') and self._model is not None:
            self._model.disconnect_by_func(self._model_changed)
        self._init_model()

    def manage_model(self):
        window=STTModelChooserDialog(model=self._model)
        window.set_transient_for(self.get_root())
        window.present()

    @Gtk.Template.Callback()
    def _manage_model_button_clicked_cb(self, button):
        self.manage_model()

    def update_description(self):
        if self._model.available() == False:
            self.set_subtitle(_("No model downloaded yet"))
            return

        model_name=self._model.get_name()
        if model_name in [None, ""]:
            model_path = self._model.get_path()
            if model_path and model_path != "":
                self.set_subtitle(_("Custom model: %s") % model_path)
            else:
                self.set_subtitle(_("Custom model installed manually in a non-standard directory"))
            return

        backend = self._settings.get_string("backend")
        if backend == "parakeet":
            manager = stt_parakeet_online_model_manager()
        elif backend == "whisper":
            manager = stt_whisper_online_model_manager()
        else:
            manager = stt_vosk_online_model_manager()

        model = manager.get_model_description(model_name)
        if model is None:
            self.set_subtitle(_("No description available for the current model (name not found in online database)"))
            return

        if model.size in [None, ""]:
            size=_("unknown size")
        else:
            size=model.size

        description=""
        if model.is_obsolete == True:
            description=_("This model is obsolete - %s") % size
        elif model.type is not None:
            if model.type.startswith("big") == True:
                description=_("Large model that may be more accurate than smaller ones - %s") % size
            else:
                description=_("Lightweight model for Android and RPi - %s") % size
        else:
            description=_("No description available for the current model (name not found in online database)")

        self.set_subtitle(description)

    def _model_changed(self, model):
        self.update_description()



---Sttconfigdialog 

import logging
import locale

from gettext import gettext as _

import gi

gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')

from gi.repository import Gtk, Gio, Adw

from sttutils import *
from sttlocalerow import STTLocaleRow
from sttshortcutrow import STTShortcutRow
from sttshortcutdialog import STTShortcutDialog

from sttcurrentlocale import stt_current_locale
from sttvoskmodelmanagers import stt_vosk_online_model_manager
from sttwhispermodelmanagers import stt_whisper_online_model_manager
from sttparakeetmodelmanagers import stt_parakeet_online_model_manager

from sttgstvosk import STTGstVosk

LOG_MSG=logging.getLogger()

@Gtk.Template(resource_path="/org/freedesktop/ibus/engine/stt/config/sttconfigdialog.ui")
class STTConfigDialog (Adw.PreferencesWindow):
    __gtype_name__="STTConfigDialog"

    localelistbox=Gtk.Template.Child()

    default_locale_switch=Gtk.Template.Child()
    preload_model_switch=Gtk.Template.Child()
    active_on_start_switch=Gtk.Template.Child()
    backend_dropdown=Gtk.Template.Child()

    cancel_button=Gtk.Template.Child()

    commandslistbox=Gtk.Template.Child()
    caselistbox=Gtk.Template.Child()
    diacriticslistbox=Gtk.Template.Child()
    punctuationlistbox=Gtk.Template.Child()
    customlistbox=Gtk.Template.Child()

    commands_row=Gtk.Template.Child()
    case_row=Gtk.Template.Child()
    diacritics_row=Gtk.Template.Child()
    punctuation_row=Gtk.Template.Child()

    categorypage=Gtk.Template.Child()
    category_stack=Gtk.Template.Child()

    commandspage=Gtk.Template.Child()
    casepage=Gtk.Template.Child()
    diacriticspage=Gtk.Template.Child()
    punctuationpage=Gtk.Template.Child()
    custompage=Gtk.Template.Child()

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._valid_formatting_file_path=False
        self._valid_formatting_file=False
        self._valid_override_file=False

        self._settings=Gio.Settings.new("org.freedesktop.ibus.engine.stt")
        self._settings.bind("preload", self.preload_model_switch, "active", Gio.SettingsBindFlags.DEFAULT)
        self._settings.bind("active-on-start", self.active_on_start_switch, "active", Gio.SettingsBindFlags.DEFAULT)

        # Setup backend selection
        self._backend_changed_id = self._settings.connect("changed::backend", self._backend_changed_cb)
        backend = self._settings.get_string("backend")
        if backend == "parakeet":
            self.backend_dropdown.set_selected(2)
        elif backend == "whisper":
            self.backend_dropdown.set_selected(1)
        else:
            self.backend_dropdown.set_selected(0)

        self._locales = {}
        self._values_dict={}
        self._utterances_dict={}
        self._no_model_toast=None
        self._unsupported_locale_toast=None

        # Make sure all managers are initialized before what follows
        stt_vosk_online_model_manager()
        stt_whisper_online_model_manager()
        stt_parakeet_online_model_manager()

        # Load current locale
        self._current_locale = stt_current_locale()
        self._locale_sig_id=self._current_locale.connect("changed", self._locale_changed_cb)
        self._override_file_changed_id=self._current_locale.connect("override-file-changed", self._override_file_changed_cb)
        self._override_file_written=False

        # Add system locale first (even if it's not a supported locale).
        system_locale=locale.getlocale()[0]
        self._add_locale_row(system_locale)

        # If current locale is not system locale, add it then.
        if system_locale != self._current_locale.locale:
            self._add_locale_row(self._current_locale.locale)

        # Load all available locales
        supported_locales=stt_vosk_online_model_manager().supported_locales()
        supported_locales.sort()

        for locale_str in supported_locales:
            # Check we are not loading the current locale twice
            if locale_str in [self._current_locale.locale, system_locale]:
                continue

            LOG_MSG.debug("loading %s", locale_str)
            self._add_locale_row(locale_str)

        # This updates _valid_formatting_file and _valid_override_file
        self._load_utterances()

        # Force preloading for the recognition engine whatever the DCONF settings
        self._engine=STTGstVosk(current_locale=self._current_locale)
        self._engine.connect("model-changed", self._engine_model_changed_cb)
        self._engine.preload()

        LOG_MSG.debug("model exists %s", self._engine.has_model())

        # Update sensitivity and such
        if self.default_locale_switch.get_active() != self._current_locale.default_locale:
            self.default_locale_switch.set_active(self._current_locale.default_locale)

        self._set_locale_rows_sensitivity()

        if self._engine.has_model() == False:
            self._engine_has_no_model()

        if self._valid_formatting_file == False:
            self._unsupported_locale()

        self._toast_action=Gio.SimpleAction.new("manage_model", None)
        action_group=Gio.SimpleActionGroup.new()
        action_group.insert(self._toast_action)
        self.insert_action_group("toast", action_group)
        self._toast_action.connect("activate", self._manage_model_action_activated)

    def _set_locale_rows_sensitivity(self):
        for row in self._locales.values():
            if row.check_button.get_active() == True:
                row.set_sensitive(True)
            else:
                row.set_sensitive(not self._current_locale.default_locale)

    def _add_locale_row(self, locale_str):
        if len(self._locales) == 0:
            row = STTLocaleRow(current_locale=self._current_locale, locale_str=locale_str, radio_group=None)
        elif self._locales.get(locale_str, None) != None:
            LOG_MSG.error("the locale is already included (%s)", locale_str)
            return
        else:
            row = next(iter(self._locales.items()))[1]
            row = STTLocaleRow(current_locale=self._current_locale, locale_str=locale_str, radio_group=row.check_button)

        self.localelistbox.add(row)
        self._locales[locale_str]=row

    def _empty_shortcut_page(self):
        self._valid_formatting_file_path=False
        self._valid_formatting_file=False
        self._valid_override_file=False

        for row in self._values_dict.values():
            listbox=row.pref_group
            listbox.remove(row)

        self.commands_row.set_visible(False)
        self.case_row.set_visible(False)
        self.diacritics_row.set_visible(False)
        self.punctuation_row.set_visible(False)

        self._values_dict={}
        self._utterances_dict={}

    def _load_current_locale(self):
        row = self._locales.get(self._current_locale.locale, None)
        if row == None:
            self._add_locale_row(self._current_locale.locale)

        self._empty_shortcut_page()
        self._load_utterances()

        if self._engine.has_model() == False:
            self._engine_has_no_model()
            return

        if self._no_model_toast != None:
            self._no_model_toast.dismiss()
            self._no_model_toast = None

        if self._valid_formatting_file == False:
            self._unsupported_locale()
        elif self._unsupported_locale_toast != None:
            self._unsupported_locale_toast.dismiss()
            self._unsupported_locale_toast = None

    def _locale_changed_cb(self, current_locale):
        if self.default_locale_switch.get_active() != self._current_locale.default_locale:
            self.default_locale_switch.set_active(self._current_locale.default_locale)

        self._set_locale_rows_sensitivity()
        self._load_current_locale()

    def _override_file_changed_cb(self, current_locale, deleted):
        if deleted == False and self._override_file_written == False:
            LOG_MSG.debug("override file changed")
            self._load_current_locale()

        self._override_file_written=False

    def _error_dialog_response_cb(self, dialog, response):
        dialog.destroy()

    def open_locale_file_cb(self, dialog, response):
        if response != Gtk.ResponseType.ACCEPT:
            dialog.destroy()
            return

        file=dialog.get_file()
        dialog.destroy()
        self._current_locale.formatting_file_path(file.get_path())

    @Gtk.Template.Callback()
    def backend_dropdown_selected_cb(self, dropdown, param):
        selected = dropdown.get_selected()
        if selected == 2:
            backend = "parakeet"
        elif selected == 1:
            backend = "whisper"
        else:
            backend = "vosk"

        current_backend = self._settings.get_string("backend")

        if backend != current_backend:
            self._settings.set_string("backend", backend)
            self._reload_locale_rows()

    def _backend_changed_cb(self, settings, key):
        self._reload_locale_rows()

    def _reload_locale_rows(self):
        for row in self._locales.values():
            if row.check_button.get_active() == True:
                row.set_sensitive(True)

    @Gtk.Template.Callback()
    def default_locale_switched_cb(self, switch, value):
        if switch.get_active() == True:
            self._current_locale.locale="None"
        else:
            self._current_locale.locale=self._current_locale.locale

        self._set_locale_rows_sensitivity()

    @Gtk.Template.Callback()
    def new_formatting_file_button_clicked_cb(self, button):
        dialog=Gtk.FileChooserDialog(transient_for=self, title=_("Open Formatting File"), modal=True, action=Gtk.FileChooserAction.OPEN)
        dialog.add_buttons(_("Cancel"), Gtk.ResponseType.CANCEL, _("Open"), Gtk.ResponseType.ACCEPT)
        dialog.connect("response", self.open_locale_file_cb)
        dialog.set_transient_for(self)
        dialog.present()

    @Gtk.Template.Callback()
    def commands_row_activated_cb(self, row):
        self.present_subpage(self.categorypage)
        self.category_stack.set_visible_child(self.commandspage)

    @Gtk.Template.Callback()
    def case_row_activated_cb(self, row):
        self.present_subpage(self.categorypage)
        self.category_stack.set_visible_child(self.casepage)

    @Gtk.Template.Callback()
    def diacritics_row_activated_cb(self, row):
        self.present_subpage(self.categorypage)
        self.category_stack.set_visible_child(self.diacriticspage)

    @Gtk.Template.Callback()
    def punctuation_row_activated_cb(self, row):
        self.present_subpage(self.categorypage)
        self.category_stack.set_visible_child(self.punctuationpage)

    @Gtk.Template.Callback()
    def custom_row_activated_cb(self, row):
        self.present_subpage(self.categorypage)
        self.category_stack.set_visible_child(self.custompage)

    @Gtk.Template.Callback()
    def cancel_button_clicked_cb(self, button):
        self.close_subpage()

    def _apply_change(self):
        LOG_MSG.debug("override file being written")
        self._override_file_written=True

        json_data={}
        command_values=[]
        json_data["commands"]=command_values
        case_values=[]
        json_data["case"]=case_values
        diacritics_values=[]
        json_data["diacritics"]=diacritics_values
        punctuation_values=[]
        json_data["punctuation"]=punctuation_values
        custom_values=[]
        json_data["custom"]=custom_values

        write_changes=False
        for row in self._values_dict.values():
            value=row.get_json_data()
            if value == None:
                continue

            write_changes=True
            if row.pref_group == self.commandslistbox:
                command_values.append(value)
            elif row.pref_group == self.caselistbox:
                case_values.append(value)
            elif row.pref_group == self.diacriticslistbox:
                diacritics_values.append(value)
            elif row.pref_group == self.punctuationlistbox:
                punctuation_values.append(value)
            elif row.pref_group == self.customlistbox:
                custom_values.append(value)

        if write_changes == True:
            self._current_locale.overriding=json_data

    def shortcut_row_reset_cb(self, row):
        for utterance in row._extra_utterances:
            self._utterances_dict.pop(utterance)

        self._apply_change()

    def shortcut_row_deleted_cb(self, row):
        self._values_dict.pop(row.value)
        for utterance in row.utterances:
            self._utterances_dict.pop(utterance)
        for utterance in row._extra_utterances:
            self._utterances_dict.pop(utterance)

        parent = row.get_parent()
        parent.remove(row)

        self._apply_change()

    def shortcut_dialog_response_cb(self, dialog, response):
        if response == Gtk.ResponseType.APPLY:
            (added_utterances, removed_utterances)=dialog.apply_to_row()
            for utterance in added_utterances:
                self._utterances_dict[utterance] = True
            for utterance in removed_utterances:
                self._utterances_dict.pop(utterance)

            self._apply_change()
        elif response == Gtk.ResponseType.OK:
            row = dialog.get_new_row()
            row.pref_group=self.customlistbox
            self.customlistbox.add(row)
            row.connect("activated", self.shortcut_row_activated_cb)
            row.connect("delete", self.shortcut_row_deleted_cb)
            row.connect("reset", self.shortcut_row_reset_cb)

            self._values_dict[row.value]=row

            for utterance in row._extra_utterances:
                self._utterances_dict[utterance] = True

            self._apply_change()

        dialog.destroy()

    def present_shortcut_dialog(self, row):
        dialog = STTShortcutDialog(row=row, engine=self._engine, transient_for=self)
        dialog.connect("response", self.shortcut_dialog_response_cb)
        dialog.present()

    def shortcut_row_activated_cb(self, row):
        self.present_shortcut_dialog(row)

    @Gtk.Template.Callback()
    def new_shortcut_clicked_cb(self, button):
        self.present_shortcut_dialog(None)

    def _load_section(self, json_data, section, listbox, cat_row):
        item_list=json_data.get(section)
        if item_list  in (None,[]):
            if cat_row != None:
                cat_row.set_visible(False)
            return

        if cat_row != None:
            cat_row.set_visible(True)

        for item in item_list:
            value=item.get("value")
            utterances=item.get("utterances")
            description=item.get("description")

            if isinstance(utterances,str):
                utterances = [utterances]

            for utterance in utterances[:]:
                existing_row = self._utterances_dict.get(utterance, False)
                if existing_row == True:
                    LOG_MSG.error("utterance already exists (%s)", utterance)
                    utterances.remove(utterance)
                    continue

                self._utterances_dict[utterance] = True

            if isinstance(value,list):
                row=self._values_dict.get(value[0], None)
            else:
                row=self._values_dict.get(value, None)

            if row == None:
                if utterances == []:
                    continue

                row=STTShortcutRow(value=value,
                                   utterances=utterances,
                                   description=description,
                                   editable=False,
                                   pref_group=listbox)
                listbox.add(row)
                row.connect("activated", self.shortcut_row_activated_cb)
                row.connect("reset", self.shortcut_row_reset_cb)

                if isinstance(value, list):
                    self._values_dict[value[0]]=row
                else:
                    self._values_dict[value]=row
            else:
                row.utterances=list(set(row.utterances)|set(utterances))
                row.description=description

    def _load_formatting_file(self):
        LOG_MSG.debug("loading formatting file")
        json_data=self._current_locale.formatting
        if json_data == None:
            return

        self._load_section(json_data, "commands", self.commandslistbox, self.commands_row)
        self._load_section(json_data, "case", self.caselistbox, self.case_row)
        self._load_section(json_data, "diacritics", self.diacriticslistbox, self.diacritics_row)
        self._load_section(json_data, "punctuation", self.punctuationlistbox, self.punctuation_row)
        self._load_section(json_data, "custom", self.customlistbox, None)

        self._valid_formatting_file=True

    def _load_section_override(self, item_list, listbox):
        if item_list == None:
            return

        for item in item_list:
            value=item.get("value")
            utterances=item.get("utterances")
            description=item.get("description")

            if utterances not in (None,[]):
                if isinstance(utterances, str):
                    utterances = [utterances]

                for utterance in utterances[:]:
                    existing_row = self._utterances_dict.get(utterance, False)
                    if existing_row == True:
                        LOG_MSG.error("utterance already exists (%s)", utterance)
                        utterances.remove(utterance)
                        continue

                    self._utterances_dict[utterance] = True

            if isinstance(value,list):
                row=self._values_dict.get(value[0], None)
            else:
                row=self._values_dict.get(value, None)

            if row != None:
                if description != None:
                    row.description = description

                if utterances not in (None,[]):
                    row.add_extra_utterances(utterances)
            elif utterances not in (None,[]):
                row=STTShortcutRow(value=value,
                                   extra_utterances=utterances,
                                   description=description,
                                   editable=True,
                                   pref_group=listbox)
                listbox.add(row)
                row.connect("delete", self.shortcut_row_deleted_cb)
                row.connect("reset", self.shortcut_row_reset_cb)
                row.connect("activated", self.shortcut_row_activated_cb)
                if isinstance(value, list):
                    self._values_dict[value[0]]=row
                else:
                    self._values_dict[value]=row

    def _load_overriding_file(self):
        LOG_MSG.debug("loading overriding file")
        json_data=self._current_locale.overriding
        if json_data == None:
            return

        self._load_section_override(json_data.get("commands"), self.commandslistbox)
        self._load_section_override(json_data.get("case"), self.caselistbox)
        self._load_section_override(json_data.get("diacritics"), self.diacriticslistbox)
        self._load_section_override(json_data.get("punctuation"), self.punctuationlistbox)
        self._load_section_override(json_data.get("custom"), self.customlistbox)

        self._valid_override_file=True

    def _load_utterances(self):
        self._load_formatting_file()
        if self._valid_formatting_file == False:
            self._empty_shortcut_page()

        self._load_overriding_file()

    def _manage_model_action_activated(self, action, param):
        row = self._locales.get(self._current_locale.locale, None)
        row.manage_model()

    def _toast_dismissed(self, toast):
        if toast == self._no_model_toast:
            self._no_model_toast=None

            if self._valid_formatting_file == False:
                self._unsupported_locale()
        else:
            self._unsupported_locale_toast=None

    def _unsupported_locale(self):
        if self._no_model_toast != None:
            return

        if self._unsupported_locale_toast != None:
            return

        if self._valid_formatting_file_path == True:
            self._unsupported_locale_toast=Adw.Toast(title=_("The file that defines automatic formatting for your locale does not have the proper format."), timeout=0)
        else:
            self._unsupported_locale_toast=Adw.Toast(title=_("A file that defines automatic formatting for your locale is missing. You can manually add one."), timeout=0)

        self._unsupported_locale_toast.connect("dismissed", self._toast_dismissed)
        self.add_toast(self._unsupported_locale_toast)

    def _engine_has_no_model(self):
        if self._no_model_toast != None:
            return

        if self._unsupported_locale_toast != None:
            self._unsupported_locale_toast.dismiss()
            self._unsupported_locale_toast = None

        self._no_model_toast=Adw.Toast(title=_("There is no available model for the current locale"), timeout=0, button_label=_("Download Model"), action_name="toast.manage_model")
        self._no_model_toast.connect("dismissed", self._toast_dismissed)
        self.add_toast(self._no_model_toast)

    def _engine_model_changed_cb(self, engine):
        if engine.has_model() == False:
            self._engine_has_no_model()
        elif self._no_model_toast != None:
            self._no_model_toast.dismiss()
            self._no_model_toast = None


---- sttgstfactory.py

import logging
import weakref

from gi.repository import GObject
from gi.repository import Gio

from sttutils import *

from sttgstvosk import STTGstVosk
from sttgstwhisper import STTGstWhisper
from sttgstparakeet import STTGstParakeet

LOG_MSG=logging.getLogger()

class STTGstFactory(GObject.GObject):
    __gtype_name__ = "STTGstFactory"

    def __init__(self):
        super().__init__()

        self._current_engine=None
        self._preload=None

        self.__settings=Gio.Settings.new("org.freedesktop.ibus.engine.stt")
        self.__settings.connect("changed::preload", self.__preload_changed)
        self.__update_preloaded_engine()

    def new_engine(self):
        engine=None if self._current_engine is None else self._current_engine()
        if engine is None:
            LOG_MSG.debug("new engine")
            backend = self.__settings.get_string("backend")
            if backend == "parakeet":
                LOG_MSG.info("Using Parakeet backend")
                engine=STTGstParakeet()
            elif backend == "whisper":
                LOG_MSG.info("Using Whisper backend")
                engine=STTGstWhisper()
            else:
                LOG_MSG.info("Using Vosk backend")
                engine=STTGstVosk()
            self._current_engine=weakref.ref(engine)
        else:
            engine.hold()

        return engine

    def __update_preloaded_engine(self):
        preload=self.__settings.get_boolean("preload")
        if preload == (self._preload is not None):
            return

        if preload is True:
            self._preload=self.new_engine()
            LOG_MSG.info("preloading engine")
            self._preload.preload()
        else:
            LOG_MSG.info("unloading engine")
            self._preload.release()
            self._preload=None

    def __preload_changed(self, settings, key):
        self.__update_preloaded_engine()

_GLOBAL_FACTORY = None

def stt_gst_factory_default():
    global _GLOBAL_FACTORY

    if _GLOBAL_FACTORY == None:
        _GLOBAL_FACTORY = STTGstFactory()

    return _GLOBAL_FACTORY








import logging
import weakref

from gi.repository import GObject
from gi.repository import Gio

from sttutils import *

from sttgstvosk import STTGstVosk
from sttgstwhisper import STTGstWhisper
# NOTE: STTGstParakeet is intentionally NOT imported here at module level.
# nemo_toolkit pulls in onnx/protobuf and takes several seconds to load.
# We import it lazily only when the user has actually selected the Parakeet backend.

LOG_MSG=logging.getLogger()

class STTGstFactory(GObject.GObject):
    __gtype_name__ = "STTGstFactory"

    def __init__(self):
        super().__init__()

        self._current_engine=None
        self._preload=None

        self.__settings=Gio.Settings.new("org.freedesktop.ibus.engine.stt")
        self.__settings.connect("changed::preload", self.__preload_changed)
        self.__update_preloaded_engine()

    def new_engine(self):
        engine=None if self._current_engine is None else self._current_engine()
        if engine is None:
            LOG_MSG.debug("new engine")
            backend = self.__settings.get_string("backend")
            if backend == "parakeet":
                LOG_MSG.info("Using Parakeet backend")
                # Lazy import: only pay the nemo/onnx startup cost when needed
                from sttgstparakeet import STTGstParakeet
                engine=STTGstParakeet()
            elif backend == "whisper":
                LOG_MSG.info("Using Whisper backend")
                engine=STTGstWhisper()
            else:
                LOG_MSG.info("Using Vosk backend")
                engine=STTGstVosk()
            self._current_engine=weakref.ref(engine)
        else:
            engine.hold()

        return engine

    def __update_preloaded_engine(self):
        preload=self.__settings.get_boolean("preload")
        if preload == (self._preload is not None):
            return

        if preload is True:
            self._preload=self.new_engine()
            LOG_MSG.info("preloading engine")
            self._preload.preload()
        else:
            LOG_MSG.info("unloading engine")
            self._preload.release()
            self._preload=None

    def __preload_changed(self, settings, key):
        self.__update_preloaded_engine()

_GLOBAL_FACTORY = None

def stt_gst_factory_default():
    global _GLOBAL_FACTORY

    if _GLOBAL_FACTORY == None:
        _GLOBAL_FACTORY = STTGstFactory()

    return _GLOBAL_FACTORY
